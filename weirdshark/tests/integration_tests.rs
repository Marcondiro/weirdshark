use std::net::IpAddr;
use std::path::Path;
use weirdshark::*;
use pnet::datalink::channel;
use pnet::datalink::Channel::Ethernet;

#[test]
fn packet_is_recorded() {
    // a sample DNS query for www.mozilla.org
    let packet = [0x08, 0x00, 0x45, 0x00, 0x00, 0x48, 0x5a, 0x7d, 0x40, 0x00, 0x40, 0x11,
        0xa3, 0xb2, 0xac, 0x10, 0x85, 0xfb, 0x0a, 0x60, 0x00, 0x0a, 0x93, 0xc2, 0x00, 0x35, 0x00,
        0x34, 0x3c, 0xbb, 0x82, 0xad, 0x01, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01,
        0x03, 0x77, 0x77, 0x77, 0x07, 0x6d, 0x6f, 0x7a, 0x69, 0x6c, 0x6c, 0x61, 0x03, 0x6f, 0x72,
        0x67, 0x00, 0x00, 0x01, 0x00, 0x01, 0x00, 0x00, 0x29, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00,
    ];
    let source_ip = [172u8, 16, 133, 251];
    let dest_ip = [10u8, 96, 0, 10];
    let source_port = 37826;
    let dest_port = 53;
    let transport_protocol = TransportProtocols::UDP;

    let path = Path::new("./tests");
    if !path.exists() {
        std::fs::create_dir(path).expect("Cannot create dir tests");
    }
    let capturer_builder = CapturerBuilder::default()
        .report_path(&path)
        .add_directed_filter_ip(DirectedFilter::only_source(
            Filter::from_vec([IpAddr::from(source_ip)].to_vec()))
        )
        .add_directed_filter_ip(DirectedFilter::only_destination(
            Filter::from_vec([IpAddr::from(dest_ip)].to_vec()))
        )
        .add_directed_filter_port(DirectedFilter::only_source(
            Filter::from_vec([source_port].to_vec())
        ))
        .add_directed_filter_port(DirectedFilter::only_destination(
            Filter::from_vec([dest_port].to_vec())
        ))
        .add_transport_protocol_filter(Some(transport_protocol));
    let interface = capturer_builder.get_interface().unwrap();

    let mac = interface.mac.unwrap().octets();
    let mut frame = Vec::new();
    frame.extend_from_slice(&mac); // destination MAC
    frame.extend_from_slice(&mac); // source MAC
    frame.extend_from_slice(&packet);

    let mut pnet_sender = match channel(&interface, Default::default()) {
        Ok(Ethernet(sender, _)) => sender,
        Ok(_) => panic!("Unhandled channel type"),
        Err(e) => panic!("Unable to create channel: {}", e),
    };

    let capturer = capturer_builder.build().unwrap();
    capturer.start().unwrap();
    std::thread::sleep(std::time::Duration::from_millis(500));
    pnet_sender.send_to(&frame, None).unwrap().unwrap();
    std::thread::sleep(std::time::Duration::from_millis(500));
    capturer.stop().unwrap();

    let paths = std::fs::read_dir(path).unwrap();
    let report = paths.filter(
        |p| match p {
            Ok(f) => f.file_name().to_str().unwrap().ends_with(".csv"),
            _ => false
        }
    ).next().unwrap().unwrap().path();

    let mut rdr = csv::Reader::from_path(&report).unwrap();
    rdr.deserialize().filter(
        |res: &Result<Record, csv::Error>| match res {
            Ok(r) => r.source_ip == IpAddr::from(source_ip) &&
                r.destination_ip == IpAddr::from(dest_ip) &&
                r.transport_protocol == TransportProtocols::UDP &&
                r.source_port == source_port &&
                r.destination_port == dest_port,
            _ => panic!("Cannot deserialize csv"),
        }
    ).next().expect("Packet not recorded.").unwrap();

    std::fs::remove_file(&report).unwrap();
}

static HTTP_REQ: &'static [u8] = &[
    0xe4, 0x18, 0x6b, 0x70, 0xb9, 0x48, 0x94, 0xe6, 0xf7, 0xd4, 0xd5, 0xc3, 0x08, 0x00, 0x45, 0x00,
    0x00, 0xc1, 0x84, 0x2d, 0x40, 0x00, 0x40, 0x06, 0xac, 0x91, 0xc0, 0xa8, 0x01, 0x91, 0x8e, 0xfa,
    0xb8, 0x44, 0xd8, 0x26, 0x00, 0x50, 0x5a, 0x53, 0xb6, 0x96, 0x93, 0x17, 0x7f, 0xee, 0x80, 0x18,
    0x01, 0xf6, 0x0a, 0x2c, 0x00, 0x00, 0x01, 0x01, 0x08, 0x0a, 0xbb, 0x27, 0x78, 0xcf, 0xc2, 0xc2,
    0x45, 0x59, 0x47, 0x45, 0x54, 0x20, 0x2f, 0x20, 0x48, 0x54, 0x54, 0x50, 0x2f, 0x31, 0x2e, 0x31,
    0x0d, 0x0a, 0x55, 0x73, 0x65, 0x72, 0x2d, 0x41, 0x67, 0x65, 0x6e, 0x74, 0x3a, 0x20, 0x57, 0x67,
    0x65, 0x74, 0x2f, 0x31, 0x2e, 0x32, 0x30, 0x2e, 0x33, 0x20, 0x28, 0x6c, 0x69, 0x6e, 0x75, 0x78,
    0x2d, 0x67, 0x6e, 0x75, 0x29, 0x0d, 0x0a, 0x41, 0x63, 0x63, 0x65, 0x70, 0x74, 0x3a, 0x20, 0x2a,
    0x2f, 0x2a, 0x0d, 0x0a, 0x41, 0x63, 0x63, 0x65, 0x70, 0x74, 0x2d, 0x45, 0x6e, 0x63, 0x6f, 0x64,
    0x69, 0x6e, 0x67, 0x3a, 0x20, 0x69, 0x64, 0x65, 0x6e, 0x74, 0x69, 0x74, 0x79, 0x0d, 0x0a, 0x48,
    0x6f, 0x73, 0x74, 0x3a, 0x20, 0x77, 0x77, 0x77, 0x2e, 0x67, 0x6f, 0x6f, 0x67, 0x6c, 0x65, 0x2e,
    0x63, 0x6f, 0x6d, 0x0d, 0x0a, 0x43, 0x6f, 0x6e, 0x6e, 0x65, 0x63, 0x74, 0x69, 0x6f, 0x6e, 0x3a,
    0x20, 0x4b, 0x65, 0x65, 0x70, 0x2d, 0x41, 0x6c, 0x69, 0x76, 0x65, 0x0d, 0x0a, 0x0d, 0x0a
];

static HTTP_RES: &'static [u8] = &[
    0x94, 0xe6, 0xf7, 0xd4, 0xd5, 0xc3, 0xe4, 0x18, 0x6b, 0x70, 0xb9, 0x48, 0x08, 0x00, 0x45, 0x00,
    0x01, 0x27, 0xa3, 0x66, 0x00, 0x00, 0x7b, 0x06, 0x91, 0xf2, 0x8e, 0xfa, 0xb8, 0x44, 0xc0, 0xa8,
    0x01, 0x91, 0x00, 0x50, 0xd8, 0x26, 0x93, 0x17, 0xb7, 0x52, 0x5a, 0x53, 0xb7, 0x23, 0x80, 0x18,
    0x01, 0x05, 0xf2, 0xea, 0x00, 0x00, 0x01, 0x01, 0x08, 0x0a, 0xc2, 0xc2, 0x47, 0x51, 0xbb, 0x27,
    0x78, 0xcf, 0x78, 0x20, 0x38, 0x70, 0x78, 0x20, 0x30, 0x20, 0x72, 0x67, 0x62, 0x61, 0x28, 0x30,
    0x2c, 0x30, 0x2c, 0x30, 0x2c, 0x30, 0x2e, 0x32, 0x29, 0x2c, 0x30, 0x20, 0x30, 0x20, 0x30, 0x20,
    0x31, 0x70, 0x78, 0x20, 0x72, 0x67, 0x62, 0x61, 0x28, 0x30, 0x2c, 0x30, 0x2c, 0x30, 0x2c, 0x30,
    0x2e, 0x30, 0x38, 0x29, 0x5c, 0x78, 0x32, 0x32, 0x2c, 0x5c, 0x78, 0x32, 0x32, 0x73, 0x62, 0x70,
    0x6c, 0x5c, 0x78, 0x32, 0x32, 0x3a, 0x31, 0x36, 0x2c, 0x5c, 0x78, 0x32, 0x32, 0x73, 0x62, 0x70,
    0x72, 0x5c, 0x78, 0x32, 0x32, 0x3a, 0x31, 0x36, 0x2c, 0x5c, 0x78, 0x32, 0x32, 0x73, 0x63, 0x64,
    0x5c, 0x78, 0x32, 0x32, 0x3a, 0x31, 0x30, 0x2c, 0x5c, 0x78, 0x32, 0x32, 0x73, 0x74, 0x6f, 0x6b,
    0x5c, 0x78, 0x32, 0x32, 0x3a, 0x5c, 0x78, 0x32, 0x32, 0x71, 0x64, 0x32, 0x32, 0x43, 0x59, 0x4e,
    0x6c, 0x6f, 0x2d, 0x41, 0x54, 0x63, 0x67, 0x66, 0x55, 0x75, 0x36, 0x4a, 0x74, 0x77, 0x50, 0x69,
    0x56, 0x6a, 0x67, 0x55, 0x5c, 0x78, 0x32, 0x32, 0x2c, 0x5c, 0x78, 0x32, 0x32, 0x75, 0x68, 0x64,
    0x65, 0x5c, 0x78, 0x32, 0x32, 0x3a, 0x66, 0x61, 0x6c, 0x73, 0x65, 0x7d, 0x7d, 0x27, 0x3b, 0x67,
    0x6f, 0x6f, 0x67, 0x6c, 0x65, 0x2e, 0x70, 0x6d, 0x63, 0x3d, 0x4a, 0x53, 0x4f, 0x4e, 0x2e, 0x70,
    0x61, 0x72, 0x73, 0x65, 0x28, 0x70, 0x6d, 0x63, 0x29, 0x3b, 0x7d, 0x29, 0x28, 0x29, 0x3b, 0x3c,
    0x2f, 0x73, 0x63, 0x72, 0x69, 0x70, 0x74, 0x3e, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,
    0x3c, 0x2f, 0x62, 0x6f, 0x64, 0x79, 0x3e, 0x3c, 0x2f, 0x68, 0x74, 0x6d, 0x6c, 0x3e, 0x0d, 0x0a,
    0x30, 0x0d, 0x0a, 0x0d, 0x0a
];